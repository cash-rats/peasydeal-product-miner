// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: product_drafts.sql

package sqlcdb

import (
	"context"
)

const createProductDraft = `-- name: CreateProductDraft :exec

INSERT INTO product_drafts (
  id,
  status,
  draft_payload,
  error,
  created_by
) VALUES (
  ?,
  ?,
  ?,
  ?,
  ?
)
`

type CreateProductDraftParams struct {
	ID           string      `json:"id"`
	Status       string      `json:"status"`
	DraftPayload string      `json:"draft_payload"`
	Error        interface{} `json:"error"`
	CreatedBy    interface{} `json:"created_by"`
}

// Product drafts (Turso / SQLite)
func (q *Queries) CreateProductDraft(ctx context.Context, arg CreateProductDraftParams) error {
	_, err := q.db.ExecContext(ctx, createProductDraft,
		arg.ID,
		arg.Status,
		arg.DraftPayload,
		arg.Error,
		arg.CreatedBy,
	)
	return err
}

const getProductDraft = `-- name: GetProductDraft :one
SELECT
  id,
  status,
  draft_payload,
  error,
  created_by,
  created_at_ms,
  updated_at_ms,
  published_at_ms,
  published_product_id
FROM product_drafts
WHERE id = ?
`

type GetProductDraftRow struct {
	ID                 string      `json:"id"`
	Status             string      `json:"status"`
	DraftPayload       string      `json:"draft_payload"`
	Error              interface{} `json:"error"`
	CreatedBy          interface{} `json:"created_by"`
	CreatedAtMs        int64       `json:"created_at_ms"`
	UpdatedAtMs        int64       `json:"updated_at_ms"`
	PublishedAtMs      interface{} `json:"published_at_ms"`
	PublishedProductID interface{} `json:"published_product_id"`
}

func (q *Queries) GetProductDraft(ctx context.Context, id string) (GetProductDraftRow, error) {
	row := q.db.QueryRowContext(ctx, getProductDraft, id)
	var i GetProductDraftRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.DraftPayload,
		&i.Error,
		&i.CreatedBy,
		&i.CreatedAtMs,
		&i.UpdatedAtMs,
		&i.PublishedAtMs,
		&i.PublishedProductID,
	)
	return i, err
}

const listProductDraftsByStatus = `-- name: ListProductDraftsByStatus :many
SELECT
  id,
  status,
  url,
  source,
  title,
  currency,
  price,
  error,
  created_by,
  created_at_ms,
  updated_at_ms,
  published_at_ms,
  published_product_id
FROM product_drafts
WHERE status = ?
ORDER BY updated_at_ms DESC
LIMIT ?
`

type ListProductDraftsByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
}

type ListProductDraftsByStatusRow struct {
	ID                 string      `json:"id"`
	Status             string      `json:"status"`
	Url                *string     `json:"url"`
	Source             *string     `json:"source"`
	Title              *string     `json:"title"`
	Currency           *string     `json:"currency"`
	Price              *string     `json:"price"`
	Error              interface{} `json:"error"`
	CreatedBy          interface{} `json:"created_by"`
	CreatedAtMs        int64       `json:"created_at_ms"`
	UpdatedAtMs        int64       `json:"updated_at_ms"`
	PublishedAtMs      interface{} `json:"published_at_ms"`
	PublishedProductID interface{} `json:"published_product_id"`
}

func (q *Queries) ListProductDraftsByStatus(ctx context.Context, arg ListProductDraftsByStatusParams) ([]ListProductDraftsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductDraftsByStatus, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductDraftsByStatusRow
	for rows.Next() {
		var i ListProductDraftsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Url,
			&i.Source,
			&i.Title,
			&i.Currency,
			&i.Price,
			&i.Error,
			&i.CreatedBy,
			&i.CreatedAtMs,
			&i.UpdatedAtMs,
			&i.PublishedAtMs,
			&i.PublishedProductID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
